################################################################################
  Kodowanie Windows-1250, koniec wiersza CR+LF, test: Za¿ó³æ gêœl¹ jaŸñ
  FreeList - Bardzo szybki alokator pamiêci
  Copyleft (C) 2007 Adam Sawicki
  Licencja: GNU LGPL
  Kontakt: mailto:sawickiap@poczta.onet.pl , http://regedit.gamedev.pl/
################################################################################


Modu³ FreeList rozszerza przestrzeñ nazw common o dwa szablony klas - FreeList
oraz DynamicFreeList. Obiekty tych klas to napisane we w³asnym zakresie
alokatory przeznaczone do alokowania du¿ych iloœci zmiennych jednego wybranego
typu, które dzia³aj¹ znacz¹co szybciej ni¿ standardowe operatory new i delete.

FreeList nadaj¹ siê dobrze wszêdzie tam, gdzie czêsto trzeba alokowaæ i zwalniaæ
ró¿ne drobiazgi (niekoniecznie ma³e rozmiarem, bo dzia³aj¹ szybciej zarówno dla
ma³ych jak i du¿ych elementów), na przyk³ad struktury cz¹steczek czy wêz³y
drzewa BSP.

Zalety:
- Znacz¹co szybsza alokacja i zwalnianie obiektów.
- Poprawiona Spatial Locality of Reference - lepsze wykorzystanie cache.

Wady:
- Trzeba utworzyæ FreeList i korzystaæ z niej przy alokacji i zwalnianiu.
- Z powodu rezerwowania ca³ych du¿ych bloków pamiêci czêœæ pamiêci siê marnuje.


Rodzaje FreeList
================================================================================

S¹ dwie klasy. Po utworzeniu ich obiektów dalsza obs³uga wygl¹da ju¿ tak samo.

1. Klasa FreeList
Rezerwuje jeden blok o podanej liczbie elementów i jest to maksymalna liczba
elementów, jakie mo¿na z jej u¿yciem zaalokowaæ.
Konstruktor:
  FreeList(uint Capacity);

2. Klasa DynamicFreeList
Zarz¹dza ca³¹ kolekcj¹ zarezerwowanych bloków o podanym rozmiarze (liczbie
elementów w jednym bloku), potrafi rezerwowaæ nowe, a tak¿e zwalniaæ te
kompletnie nieu¿ywane (oczywiœcie z pewn¹ histerez¹).
Konstruktor:
  DynamicFreeList(uint BlockCapacity);


Obs³uga
================================================================================

#include "Base.hpp"
#include "FreeList.hpp"
using namespace common;

Utworzenie listy:
  FreeList<int> L(1024);
  DynamicFreeList<int> L(1024);

Alokacja domyœlnym konstruktorem:
(typy atomowe zostaj¹ niezainicjalizowane)
  int *p = L.New();
Alokacja jawnie wywo³anym domyœlnym konstruktorem:
(typy atomowe zostaj¹ zainicjalizowane zerem)
  int *p = L.New_ctor();
Alokacja z wywo³aniem konstruktora z parametrami:
(istniej¹ wersje dla 1, 2, 3, 4, 5 parametrów)
  int *p = L.New(123);

Zwolnienie pamiêci:
(pamiêæ musi byæ przydzielona wczeœniej z puli tej listy)
  L.Delete(p);

Sprawdzanie stanu i statystyki - metody:
- IsEmpty, IsFull
- GetUsedCount, GetFreeCount, GetCapacity, GetUsedSize itd...

Uwagi
--------------------------------------------------------------------------------

Przed ususniêciem obiektu listy zwolnione musz¹ byæ wszystkie zaalokowane z jej
u¿yciem elementy. Jest to sprawdzane za pomoc¹ asercji.

Ka¿da z wersji metod do alokacji New ma te¿ wersjê o nazwie TryNew, która w
przypadku b³êdu (brak miejsca w bloku pamiêci) nie rzuca wyj¹tku std::bad_alloc
jak tamte, tylko zwraca NULL.


Wydajnoœæ
================================================================================

Pomiar dla 10240 losowych alokacji lub zwolnieñ (90% szansa na alokacjê, 10% na
zwolnienie, na koñcu zwolnienie pozosta³ych zmiennych):

DEBUG:
Element typu int:
  FreeList : 68.0636 ms
  DynamicFreeList : 184.441 ms
  new i delete : 78.8142 ms
Element typu zajmujacego 1024 bajty:
  FreeList : 69.3896 ms
  DynamicFreeList : 203.506 ms
  new i delete : 93.2942 ms
RELEASE:
Element typu int:
  FreeList : 7.87224 ms
  DynamicFreeList : 11.4786 ms
  new i delete : 17.0348 ms
Element typu zajmujacego 1024 bajty:
  FreeList : 9.18059 ms
  DynamicFreeList : 18.0729 ms
  new i delete : 24.0537 ms

