################################################################################
  Kodowanie Windows-1250, koniec wiersza CR+LF, test: Za¿ó³æ gêœl¹ jaŸñ
  Base - Modu³ podstawowy
  Copyleft (C) 2007 Adam Sawicki
  Licencja: GNU LGPL
  Kontakt: mailto:sawickiap@poczta.onet.pl , http://regedit.gamedev.pl/
################################################################################


Wstêp
================================================================================

Ten modu³ to modu³ bazowy. Plik Base.hpp w³¹czaj¹ wszystkie pozosta³e pliki
biblioteki i u¿ytkownik równie¿ jest spodziewany aby to robiæ przed w³¹czaniem
wszelkich innych nag³ówków biblioteki, poniewa¿ korzystaj¹ one ze zdefiniowanych
w Base.hpp typów i innych elementów, a same go nie w³¹czaj¹.

Nie u¿ywa Error ani ¿adnego innego modu³u. To inne jego u¿ywaj¹. ¯adne z jego
funkcji nie zg³aszaj¹ b³êdów przez wyj¹tki.


Sk³adniki
================================================================================

- Podstawy:
  - W³¹cza:
    <cassert>, <string>, <vector>
  - Definiuje:
    using std::string;
  - Typy ca³kowitoliczbowe:
    uint1, uint2, uint4, uint8
    int1, int2, int4, int8
- Ró¿ne drobne, u¿yteczne makra i funkcje
- Operator dos³ownej reinterpretacji bitowej absolute_cast
- Inteligentne wskaŸnki i uchwyty
  > parametryzowane polityk¹ zwalniania
  > Z wy³¹czn¹ w³asnoœci¹ lub ze zliczaniem referencji
- Funkcje do operacji na znakach i ³añcuchach, w tym oprócz prostych tak¿e:
  > Konwersja miêdzy stronami kodowymi:
    Windows-1250, ISO-8859-2, IBM CP852, UTF-8
  > Dopasowanie do maski ze znakami wieloznacznymi '*' i '?'
  > Odleg³oœæ edycyjna ³añcuchów - Levenshtein Distance
  > Porównywanie ³añcuchów w tzw. porz¹dku naturalnym
- Funkcje do operacji na œcie¿kach do plików
  > Dzia³aj¹ce zarówno dla œcie¿ek Windows jak i Linux
- Konwersje ró¿nych typów do i z ³añcucha znaków, w tym:
  > W³asne IntToStr, StrToInt, UintToStr, StrToUint sprawdzaj¹ce b³êdy sk³adni i
    zakresu
  > Uogólniony, rozszerzony mechanizm konwersji zrealizowany za pomoc¹ szablonów
    SthToStr i StrToSth
  > Wygodny mechanizm formu³owania ³añcuchów korzystaj¹cy z powy¿szego, np.:
    string s = Format("x=#, y=#") % x % y;
- Dok³adny pomiar czasu i czekanie okreœlony czas
- Podstawowe typy, sta³e, makra i funkcje matematyczne, w tym oprócz prostych
  tak¿e:
  > Funkcja wyg³adzaj¹ca metod¹ Critically Damped Smoothing
  > Funkcje okresowe - sinus, trójk¹ta, prostok¹tna, pi³okszta³tna, PWM
- Generator liczb pseudolosowych
  > Bardzo szybki, deterministyczny
  > Losowanie liczb ró¿nych typów
  > Generowanie losowych danych binarnych
  > Losowanie liczb o rozk³adzie normalnym (Gaussa)
- Generator unikatowych identyfikatorów
- Parser parametrów przekazanych z wiersza poleceñ
  > Szybki i prosty w u¿yciu
  > Wsparcie zarówno dla main (int argc, char **argv), jak i WinMain (char
    *CmdLine)
  > Obs³uguje opcje krótkie (jednoznakowe) i d³ugie (wieloznakowe), w formatach:
    ] Linuksa:  -a -b -c -abc --d³uga -lARG -l ARG -l=ARG
    ] Windowsa: /a /b /c      /d³uga  /lARG /l ARG /l=ARG
- Klasa bazowa dla wzorca projektowego Singleton


absolute_cast
================================================================================

To brakuj¹cy w C++ operator dos³ownej reinterpretacji bitowej miêdzy wartoœciami
dowolnego typu. Ma sens tylko w przypadku typów o takim samym rozmiarze w sensie
liczby zajmowanych bajtów. Jest to sprytnie napisana funkcja szablonona, której
mo¿na u¿ywaæ niczym wbudowanych operatorów rzutowania C++ takich jak static_cast
czy reinterpret_cast. Jej wynalazc¹ jest Karol Kuczmarski "Xion". Przyk³ad:

	float F = 10.5f;
	uint4 I1 = static_cast<uint4>(F);
	uint4 I2 = absolute_cast<uint4>(F);

I1 bêdzie wynosi³o 10 - nast¹pi³a konwersja wartoœci liczbowej.
I2 bêdzie wynosi³o 1093140480 - nast¹pi³a dos³owna reinterpretacja bitów.

Wiêcej informacji na temat problemu konwersji miêdzy typami w C++ znajdziesz w
moim artykule "Rzutowanie typów w C++", Adam Sawicki, Czerwiec 2006,
http://regedit.gamedev.pl/produkcje/artykuly/rzutowanie_typow_w_cpp.php5


Konwersje
================================================================================

Modu³ Base oferuje konwersje miêdzy ró¿nymi typami a ³añcuchami w obydwie
strony, tak¿e z dodatkowymi opcjami. S³u¿¹ do tego funkcje takie jak np.:
IntToStr, StrToInt, FloatToStr, StrToFloat, BoolToStr, StrToBool itd.

Uogólnion¹ wersj¹ tych konwersji s¹ szablony funkcji SthToStr i StrToSth.
Obs³uguj¹ one nastêpuj¹ce typy:

- SthToStr i StrToSth:
  bool, char, int2, int4, int8, uint1, uint2, uint4, uint8, float, double,
  string, std::vector<T>
- Tylko SthToStr:
  char*, const char*, void*, const void*

Próba u¿ycia tych funkcji dla nieobs³ugiwanego typu zakoñczy siê Assertion
Failed. Mo¿na sprawdziæ, czy dany typ jest obs³ugiwany u¿ywaj¹c:

	bool B1 = StrToSth_obj<SOME_TYPE>::IsSupported();
	bool B2 = SthToStr_obj<SOME_TYPE>::IsSupported();

Mo¿na pisaæ konwersje do i z w³asnych typów. Szablon takiej konwersji jest
nastêpuj¹cy. Nale¿y zamieniæ T na konkretny typ i wpisaæ konwersjê w miejscu //.
Kod ten nale¿y wpisaæ poza jak¹kolwiek przestrzeni¹ nazw.

	template <>
	struct SthToStr_obj<T>
	{
		void operator () (string *Str, const T &Sth)
		{
			//
		}
		static inline bool IsSupported() { return true; }
	};

	template <>
	struct StrToSth_obj<T>
	{
		bool operator () (T *Sth, const string &Str)
		{
			//
		}
		static inline bool IsSupported() { return true; }
	};

Jeœli StrToSth siê nie uda, wartoœæ parametru wyjœciowego jest niezdefiniowana.

Modu³ Error rozszerza ten mechanizm o szablon funkcji MustStrToSth, który w
przypadku niepowodzenia rzuca wyj¹tek.

Klasa Format (wraz z prze³adowanym dla niej operatorem %) robi za sprintf dla
³añcuchów string. Nie jest super szybka, ale jest wygodna w u¿yciu. Obs³uguje
wszystkie te typy, co SthToStr. Sposób u¿ycia (jeœli jakiœtam OutputLine
oczekuje const string&):

	OutputLine( Format("B³¹d w pliku # w wierszu #") % "plik.txt" % 123 );

Jeœli potrzeba zapisaæ do strumienia lub z innych przyczyn operator string() nie
dzia³a, u¿ywamy metody str:

	std::cout << ( Format("B³¹d w pliku # w wierszu #") % "plik.txt" % 123 ).str();

Jeœli chcemy niestandardowe formatowanie podczas konwersji z jakiegoœ typu na
³añcuch, konwertujemy we w³asnym zakresie:

	OutputLine( Format("B³¹d w pliku # w wierszu #") % "plik.txt" % IntToStr2(123, 5) );

Jeœli potrzebujemy znaku '#' i chcemy jako specjalny u¿yæ innego znaku:

	OutputLine( Format("B³¹d # % w pliku %", '%') % 123 % "plik.txt" );


Inteligentne wskaŸniki
================================================================================

Modu³ zawiera w³asn¹, elastyczn¹ i doœæ potê¿n¹, acz prost¹ implementacjê
inteligentnych wskaŸników.


Sposób u¿ycia
--------------------------------------------------------------------------------

S¹ cztery rodzaje wskaŸników:

- Przechowuj¹ce wskaŸnik typu T* - do wskaŸników:
  - scoped_ptr
    Zwyk³y posiadaj¹cy w³asnoœæ, zwalnia w destruktorze, niekopiowalny.
  - shared_ptr
    Zliczaj¹cy referencje.
- Przechowuj¹ce bezpoœrednio wartoœæ typu T - do uchwytów:
  - scoped_handle
    Zwyk³y posiadaj¹cy w³asnoœæ, zwalnia w destruktorze, niekopiowalny.
  - shared_handle
    Zliczaj¹cy referencje.

S¹ trzy polityki zwalniania dla wskaŸników:

- DeletePolicy (domyœlna)
  Wywo³uje: delete x;
- DeleteArrayPolicy - do tablic
  Wywo³uje: delete [] x;
- ReleasePolicy - do zasobów takich jak obiekty COM
  Wywo³uje: x->Release();

Oraz dwie dla uchwytów [tylko Windows]:

- CloseHandlePolicy - wywo³uje CloseHandle(x);
- DeleteObjectPolicy - wywo³uje DeleteObject(x);

Mo¿na te¿ pisaæ w³asne polityki zwalniania. Przyk³ady:
- dla wskaŸników:
    class ReleasePolicy { public: template <typename T> static void Destroy(T *p) { if (p) p->Release(); } };
- dla uchwytów:
    class DeleteObjectPolicy { public: template <typename T> static void Destroy(T p) { if (p != NULL) DeleteObject(p); } };

Przyk³ady klas wskaŸników:

- WskaŸnik z w³asnoœci¹, sam kasuje, niekopiowalny:
    scoped_ptr<Klasa> p1;
- WskaŸnik ze zliczaniem referencji:
    shared_ptr<Klasa> p2;
- WskaŸnik do tablicy (usuwany delete[]), niekopiowalny:
    scoped_ptr<Klasa, DeleteArrayPolicy> p3;
- WskaŸnik do obiektu COM ze zliczaniem referencji:
    shared_ptr<IDirect3DTexture9, ReleasePolicy> p4;
- Uchwyt do otwartego pliku Windows API:
    typedef scoped_handle<HANDLE, CloseHandlePolicy> close_handle;
    close_handle plik(NULL);

Sposób u¿ycia scoped_ptr:

- Konstruktor domyœlny ustawia wskaŸnik pusty (NULL)
    scoped_ptr<Klasa> p1;
- Konstruktor inicjalizuj¹cy (tylko explicit):
    scoped_ptr<Klasa> p1(NULL);
    scoped_ptr<Klasa> p2(new Klasa());
- Wyzerowanie wskaŸnika (jeœli trzeba, sam zwolni obiekt):
    p1.reset();
    p1.reset(NULL);
- Ustawienie wskaŸnika na nowy obiekt (jeœli trzeba, sam zwolni stary):
    p1.reset(new Klasa());
- Odwo³anie siê pod wskaŸnik:
    Klasa obj2 = *p1;
    p1->MetodaKlasy();
- Otrzymanie prawdziwego wskaŸnika:
    Klasa *RealPtr = p1.get();
- Porównywanie wskaŸników:
    if (p1 == NULL) { }
    if (RealPtr == p1) { }
- Zamiana:
    p1.swap(p2);
    swap(p1, p2);
- Odwo³anie siê do elementu tablicy wskazywanej przez wskaŸnik:
    scoped_ptr<int, DeleteArrayPolicy> tablica(new int[1024]);
    tablica[0] = 1;

Sposób u¿ycia shared_ptr:

- Wspiera to samo co scoped_ptr plus dodatkowo...
- Skopiowanie wskaŸnika do drugiego:
  Dzia³a tak¿e dla klas sparametryzowanych typem klasy nieidentycznym, ale
  daj¹cym siê skonwertowaæ.
    shared_ptr<Klasa> p1;
    shared_ptr<Klasa> p2 = p1;
    p2 = p1;
    p2.reset(p1);
- Porównanie dwóch wskaŸników:
    if (p1 == p2) { }

Sposób u¿ycia scoped_handle i shared_handle:
Jak odpowiednio scoped_ptr lub shared_ptr, ale:
- Nie posiada operatorów: * -> []
  Trzeba pobieraæ jego wartoœæ za pomoc¹ metody get.
- Nie posiada bezparametrowego konstruktora ani operatora przypisania, ¿eby nie
  oczekiwaæ po typie wskaŸnika ¿e posiada domyœln¹ wartoœæ zerow¹ oznaczaj¹c¹
  wartoœæ pust¹. Dlatego trzeba pisaæ na przyk³ad tak:
    scoped_handle<HANDLE, CloseHandlePolicy> p1(NULL);
    p1.reset(NULL);


Szczegó³y
--------------------------------------------------------------------------------

Inteligetne wskaŸniki s¹ potrzebne, zw³aszcza do unikania wycieków pamiêci kiedy
u¿ywamy wyj¹tków. Do napisania w³asnych zmotywowa³a mnie chêæ uwolnienia siê od
biblioteki Boost. Pisanie takich wskaŸników nie jest trudne, ale wi¹¿e siê z
podjêciem szeregu trudnych decyzji projektowych. Podj¹³em nastêpuj¹ce:

- Ró¿ne sposoby zwalniania: parametryzacja szablonu specjalnym Policy
- Rodzaje w³asnoœci:
  - niekopiowalny scoped_ptr
  - zliczaj¹cy referencje shared_ptr
- Implementacja zliczania referencji: wskaŸnik przechowuje:
  - wskaŸnik do danych
  - wskaŸnik do alokowanego na stercie licznika
- Nie-explicit konstruktor oraz operator pobieraj¹cy T* : NIE
- Operator * i -> zamiast samej metody get: TAK
- Funkcje takie jak get czy reset: jako metody, nie funkcje globalne
- Przeci¹¿ony operator [] do indeksowania tablic: po namyœle jednak TAK
- Arytmetyka wskaŸników: NIE
- Konwersje z wskaŸników do innych typów: TAK
- Operatory == != : TAK
- Operatory < > <= >= : NIE
- Operator & : NIE
- Kontrola niezerowoœci wskaŸnika przy * i -> : TAK, assert
- WskaŸnik do sta³ej, sta³y wskaŸnik: OLAÆ, nic z tym nie robiê
- Bezpieczeñstwo w¹tkowe: OLAÆ, nic z tym nie robiê
- Mo¿liwoœæ przechowywania czegoœ innego ni¿ normalnego wskaŸnika T* : TAK, ale
  jako osobne klasy, bez uogólniania tego z u¿yciem Policy
- Zapobieganie UB-kowi przy destrukcji niezdefiniowanej klasy: TAK, sztuczka
  z Boost checked_delete.hpp


Singleton
================================================================================

Szablon klasy Singleton to klasa bazowa do implementacji wzorca projektowego
singletonu, czyli klasy, której g³ówny (najczêœciej jedyny) obiekt jest tworzony
automatycznie podczas pierwszego u¿ycia.

Deklarujemy tak:

	class MyClass : public Singleton<MyClass>
	{
		int MyMethod(int x);
	};

U¿ywamy tak:

	int i = MyClass::GetInstance().MyMethod(123);

Obiekt powstanie przy pierwszym u¿yciu i, jeœli kiedykolwiek powsta³, zostanie
na koñcu programu automatycznie usuniêty (wywo³a siê destruktor).


Parser wiersza poleceñ
================================================================================

Klasa CmdLineParser oferuje parsowanie parametrów przekazanych do programu z
wiersza poleceñ. Jest trochê podobna do funkcji getopt z Linuksa.

Cechy
--------------------------------------------------------------------------------

- Przenoœna, jak ca³y CommonLib, a w przeciwieñstwie do linuksowej getopt.
- Obs³uguje zarówno wiersz poleceñ z main(int argc, char **argv), jak i z
  WinMain(HINSTANCE, HINSTANCE, char *CmdLine, int).
- Obs³uguje opcje krótkie (jednoznakowe) i d³ugie (wieloznakowe), w formatach:
  > Linuksa:  -a -b -c -abc --d³uga -lARG -l ARG -l=ARG
  > Windowsa: /a /b /c      /d³uga  /lARG /l ARG /l=ARG
- Prosta w u¿yciu.
- Nie jest maksymalnie szybka.

Sposób u¿ycia
--------------------------------------------------------------------------------

1. Utworzyæ obiekt klasy CmdLineParser
   Jako parametry do odpowiedniego konstruktora podaæ argumenty wiersza poleceñ
   otrzymane w funkcji main lub WinMain. W czasie parsowania nie mog¹ siê
   zmieniaæ.
2. Zarejestrowaæ dopuszczalne opcje metod¹ RegisterOpt. Ka¿da opcja ma:
   - Identyfikator liczbowy - powinien byæ wiêkszy od 0.
   - Treœæ - jednoznakow¹ (opcja krótka) lub wieloznakow¹ (opcja d³uga)
   - Flagê, czy oczekuje parametru (dodatkowego ³añcucha za opcj¹)
3. Pobieraæ kolejne informacje metod¹ ReadNext a¿ do otrzymania RESULT_END lub
   RESULT_ERROR.

Sk³adnia
--------------------------------------------------------------------------------

U¿ycie parsera polega na pobieraniu kolejnych informacji. Mo¿liwe wartoœci:

- RESULT_END - informacji nie pobrano, koniec wiersza poleceñ
- RESULT_ERROR - informacji nie pobrano, b³¹d sk³adni
- RESULT_PARAMETER - pobrano go³y parametr bez opcji
  Mo¿esz odczytaæ treœæ parametru metod¹ GetParameter.
- RESULT_OPT - pobrano krótk¹ lub d³ug¹ opcjê
  Mo¿esz odczytaæ identyfikator opcji metod¹ GetOptId.
  Jeœli opcja przyjmuje parametr, mo¿esz odczytaæ treœæ parametru metod¹
  GetParameter.

Na przyk³ad jeœli 'a', 'b' i 'c' to opcje krótkie, z których 'c' oczekuje
parametru, dopuszczalne s¹ m.in. takie konstrukcje:

  -a -b -c parametr
  -abc parametr
  -a -b -c=parametr
  -ab -c"parametr ze spacj¹"
  "-abcparametr ze spacj¹"
  /a /b /c parametr
  /a /b /c="parametr ze spacj¹"
  /a /b "/cparametr ze spacj¹"

Jeœli natomiast "AA" i "BBB" to opcje d³ugie, z czego ta druga oczekuje
parametru, dopuszczalne s¹ m.in. takie konstrukcje:

  --AA --BB parametr
  --AA --BB=parametr
  /AA /BB="parametr ze spacj¹"
  --AA /BB "parametr ze spacj¹"

Kolejnoœæ opcji nie jest w ¿aden sposób kontrolowania, podobnie jak ich obecnoœæ
czy powtarzanie siê wiele razy. To le¿y ju¿ w gestii u¿ytkownika - parser tylko
odczytuje i zwraca kolejne napotkane informacje.

Przyk³ad
--------------------------------------------------------------------------------

Obs³ugiwana sk³adnia jest skomplikowana i oparta na dog³êbnych badaniach
zachowania wiersza poleceñ Windowsa i Linuksa. Niektóre mo¿liwoœci przedstawia
ten przyk³ad. Jeœli zarejestrowane s¹ opcje:

  RegisterOpt(1, 'a', false);
  RegisterOpt(2, 'b', false);
  RegisterOpt(3, 'c', true);
  RegisterOpt(11, "AA", false);
  RegisterOpt(12, "BBB", true);

Wiersz poleceñ wygl¹da tak:

  -a -b -c param -abc="param" "-cparam" /AA --AA "/BBB"=param DUPA --BBB "param"

Wówczas wynikiem kolejnych wywo³añ ReadNext jest:

  Result=RESULT_OPT,       Id=1,  Param=""
  Result=RESULT_OPT,       Id=2,  Param=""
  Result=RESULT_OPT,       Id=3,  Param="param"
  Result=RESULT_OPT,       Id=1,  Param=""
  Result=RESULT_OPT,       Id=2,  Param=""
  Result=RESULT_OPT,       Id=3,  Param="param"
  Result=RESULT_OPT,       Id=3,  Param="param"
  Result=RESULT_OPT,       Id=11, Param=""
  Result=RESULT_OPT,       Id=11, Param=""
  Result=RESULT_OPT,       Id=12, Param="param"
  Result=RESULT_PARAMETER, Id=0,  Param="DUPA"
  Result=RESULT_OPT,       Id=12, Param="param"
  Result=RESULT_END,       Id=0,  Param=""

