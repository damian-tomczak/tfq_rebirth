################################################################################
  Kodowanie Windows-1250, koniec wiersza CR+LF, test: Za¿ó³æ gêœl¹ jaŸñ
  Logger - Mechanizm logowania komunikatów
  Copyleft (C) 2007 Adam Sawicki
  Licencja: GNU LGPL
  Kontakt: mailto:sawickiap@poczta.onet.pl , http://regedit.gamedev.pl/
################################################################################


Wstêp
================================================================================

Logger to modu³ do logowania, czyli zapisywania krótkich komunikatów tekstowych
do pliku, na konsolê i w dowolne inne miejsca - typowo przeznaczony do
wyprowadzania informacji o zdarzeniach zachodz¹cych w programie, b³êdach itd.

W³aœciwoœci:

- Przenoœny
  Dzia³a na Windowsie i Linuksie.
- Wielow¹tkowy
  Bezpieczny w¹tkowo. Sam te¿ wykorzystuje w¹tki.
- Wypasiony
  Ma praktycznie wszelkie mo¿liwoœci jakie tylko potrafi³em wymyœliæ :)

- Uogólnienie logów
  Log to abstrakcyjny obiekt, którym mo¿e byæ plik, konsola i dowolne inne
  miejsce. Mo¿na pisaæ w³asne logi.
- Rozdzielenie komunikatów od logów
  Zapisywane komunikaty trafiaj¹ do centralnego loggera, a stamt¹d dopiero ka¿dy
  jest mapowany na zero, jeden lub wiêcej logów.
- Uogólniony podzia³ komunikatów
  Komuniaty s¹ opisywane przez maskê bitow¹, która mo¿e oznaczaæ kategoriê,
  priorytet lub cokolwiek i któr¹ mo¿na wykorzystaæ do mapowania na logi
  docelowe, na prefiksy, kolory i dowolne inne rzeczy zale¿nie od loga.


Podstawy
================================================================================

*Logger* to system logowania. Jest tylko jeden. Inicjalizuje siê go funkcj¹
CreateLogger, a finalizuje - DestroyLogger. Miêdzy tymi wywo³aniami mo¿na
otrzymaæ go funkcj¹ GetLogger.

*Log* to obiekt klasy dziedzicz¹cej z interfejsu ILog. Reprezentuje miejsce,
do którego mog¹ trafiaæ logowane komunikaty i odpowiada za ich zapisywanie
do tego miejsca. Mo¿e to byæ na przyk³ad plik tekstowy w jakimœ formacie,
realizowana z u¿yciem jakiegoœ API konsola albo cokolwiek.

Prawid³owa sekwencja wywo³añ wygl¹da jak w przyk³adzie:

	// 1. Utworzenie loggera
	//    Utworzenie logów
	logger::CreateLogger(false);
	logger::Logger & Logger = logger::GetLogger();
	logger::TextFileLog *Log = new logger::TextFileLog("Log.txt", logger::FILE_MODE_NORMAL, base::EOL_CRLF);

	// 2. Konfiguracja logów
	//    Konfiguracja loggera
	//    Zarejestrowanie logów
	Logger.AddLogMapping(0xFFFFFFFF, Log);

	// 3. U¿ywanie w czasie pracy programu
	Logger.Log(1, "Komunikat 1");
	Logger.Log(1, "Komunikat 2");
	Logger.Log(1, "Komunikat 3");

	// 4. Usuniêcie loggera
	logger::DestroyLogger();

	// 5. Usuniêcie logów
	delete Log;

Bardzo wa¿ne jest, aby logi usuwaæ dopiero po usuniêciu loggera. Wa¿ne te¿,
by po rozpoczêciu u¿ywania loggera nie dokonywaæ ju¿ ¿adnej konfiguracji
loggera ani logów, nie tworzyæ nowych logów itd.


Typy, maski, mapowanie
================================================================================

*Komunikat* to krótka wiadomoœæ tekstowa, która podlega zalogowaniu. Komunikat
sk³ada siê z treœci [string] oraz typu (uint4). Treœæ powinna byæ w kodowaniu
Windows-1250 (jak w ca³ym projekcie). Mo¿e zawieraæ koñce wiersza (w dowolnym
formacie) - logi maj¹ obowi¹zek prawid³owo obs³ugiwaæ komunikaty
wielowierszowe - ale jest to raczej niezalecane, bo powinna byæ krótka.

*Typ komunikatu* to maska bitowa. Mo¿na jej nadaæ dowolne znaczenie, np.:

- Rodzaj komunikatu
- Rodzaj nadawcy komunikatu
- Priorytet komunikatu

Komunikaty logujemy za pomoc¹ metody loggera Log podaj¹c kolejno typ i treœæ.
Logger wysy³a go do zera, jednego lub wielu logów zale¿nie od mapowania.
Podczas rejestrowania logów w loggerze podajemy *maskê bitow¹*, która bêdzie
³¹czona operatorem & z typem komunikatu i jeœli wynik bêdzie niezerowy,
komunikat trafi do danego loga. W ten sposób mo¿na mapowaæ tylko wybrane typy
komunikatów na wybrane logi. Log zarejestrowany z mask¹ 0xFFFFFFFF otrzyma
wszystkie komunikaty o niezerowym typie.

Przyk³ad mapowania typów komunikatów na logi:

	Logger.AddLogMapping(0xFFFFFFFF, Log1);
	Logger.AddLogMapping(1, Log2);

	Logger.Log(1, "Komunikat 1");
	Logger.Log(2, "Komunikat 2");
	Logger.Log(3, "Komunikat 3");

W tym przyk³adzie do Log1 trafi¹ wszystkie komunikaty, a do Log2 tylko te,
których typ ma ustawiony najm³odszy bit, czyli komunikaty 1 i 3.

Nie nale¿y rejestrowaæ logów w loggerze wiêcej ni¿ raz.


Prefiksy
================================================================================

*Prefiks* to przedrostek dodawany do treœci ka¿dego logowanego komunikatu.
Jest sk³adany indywidualnie dla ka¿dego loga na podstawie ustawionego dla niego
*formatu prefiksu*, który jest dowolnym ³añcuchem, a specjalne wartoœci s¹ w nim
zastêpowane przez:

- %D - data
- %T - czas
- %1 ... %3 - w³asne informacje prefiksu
- %% - znak "%"

Format prefiksu mo¿na ustawiæ dla loga metod¹ SetPrefixFormat. Mo¿na te¿ ustawiæ
na raz format prefiksu dla wszystkich logów zarejestrowanych w loggerze metod¹
SetPrefixFormat loggera. Ustawianie formatu prefiksu jest czêœci¹ procesu
konfiguracji.

*W³asne informacje prefiksu* to trzy ³añcuchy, które mo¿na zmieniaæ w czasie
dzia³ania programu (ich zmiana jest czêœci¹ procesu u¿ywania loggera) i które
mog¹ byæ do³¹czane do prefiksu. S¹ wspólne dla ca³ego loggera. Do ich zmiany
s³u¿y metoda SetCustomPrefixInfo. Mo¿na je wykorzystywaæ np. do wskazania
numeru bie¿¹cej klatki gry czy innych tym podobnych rzeczy.

*Prefiks typu* to dodatkowy prefiks do³¹czany za prefiksem g³ównym do treœci
logowanego komunikatu. Jest ustalonym na sta³e ³añcuchem. Ka¿dy log ma w³asne
mapowanie masek typów na prefiksy typu. Mo¿na to mapowanie wykonaæ metod¹
AddTypePrefixMapping loga. Metoda AddTypePrefixMapping loggera dokonuje go
jednoczeœnie dla wszystkich zarejestrowanych w nim logów. Jest to czêœæ procesu
konfiguracji.

Przyk³ad:

	Log1->SetPrefixFormat("[%D %T %1] ");
	Log1->AddTypePrefixMapping(1, "(!) ");
	Logger.SetCustomPrefixInfo(0, "Frame:123");

	Logger.Log(1, "Komunikat 1");
	Logger.Log(2, "Komunikat 2");
	Logger.Log(3, "Komunikat 3");

Da w efekcie mniej wiêcej takie wyjœcie:

	[2006-08-18 21:52:28 Frame:123] (!) Komunikat 1
	[2006-08-18 21:52:28 Frame:123] Komunikat 2
	[2006-08-18 21:52:28 Frame:123] (!) Komunikat 3

W przypadku kiedy typ danego komunikatu pasuje do wielu mapowañ na prefiks,
wykorzystane zostanie pierwsze z nich. Dlatego mapowania nale¿y dodawaæ
w kolejnoœci od najbardziej szczegó³owych do najbardziej ogólnych. Na przyk³ad
jeœli chcemy dodaæ mapowanie które dotyczy "wszystkich pozosta³ych" komunikatów,
dodajemy je z mask¹ 0xFFFFFFFF na samym koñcu.


Tryby pracy
================================================================================

Logger mo¿e pracowaæ w dwóch trybach:

1. BEZ KOLEJKI
Kiedy podamy podczas tworzenia loggera jako parametr CreateLogger wartoœæ false,
logger loguje komunikaty natychmiast po ich otrzymaniu.

2. Z KOLEJK¥
Kiedy podamy podczas tworzenia loggera jako parametr CreateLogger wartoœæ true,
logger tworzy osobny w¹tek zajmuj¹cy siê logowaniem. Logowane komunikaty
trafiaj¹ do specjalnej kolejki, a w¹tek pobiera je i loguje w swoim tempie.

Tryb z kolejk¹ jest szybszy, ale tryb bez kolejki jest bardziej niezawodny
w wypadku awarii programu. W trybie z kolejk¹ finalizacja loggera mo¿e potrwaæ
d³u¿sz¹ chwilê, jeœli wymaga poczekania na zalogowanie zalegaj¹cych w kolejce
komunikatów.

Kolejnoœæ wywo³añ logowania komunikatów i zmiany w³asnych informacji prefiksu
jest respektowana tak¿e w trybie z kolejk¹.

Loggery plikowe mo¿na otwieraæ w trzech trybach:

- FILE_MODE_NORMAL
- FILE_MODE_FLUSH
- FILE_MODE_REOPEN

Tryb z kolejk¹ w po³¹czeniu z FILE_MODE_NORMAL jest najszybszy.

Tryb bez kolejki w po³¹czeniu z FILE_MODE_REOPEN jest najpewniejszy - daje
gwarancjê, ¿e nawet w przypadku nag³ego wysypania siê programu wszystko, co by³o
wczeœniej logowane trafi³o do logów.


Bezpieczeñstwo w¹tkowe
================================================================================

Tworzenie logów, ich konfiguracja, konfiguracja loggera - nie s¹ bezpieczne
w¹tkowo. Dlatego nale¿y ich dokonywaæ przed rozpoczêciem u¿ywania loggera.

Logowanie i zmiana w³asnych informacji prefiksu s¹ bezpieczne w¹tkowo. Mo¿na
ich dokonywaæ z wielu w¹tków na raz.


Tworzenie w³asnych logów
================================================================================

Aby utworzyæ w³asny log, nale¿y napisaæ w³asn¹ klasê dziedzicz¹c¹ z intefejsu
ILog. Jej jedynym obowi¹zkiem jest implementacja metody OnLog, która bêdzie
mia³a za zadanie zalogowaæ komunikat. Otrzymuje ona ju¿ zredagowane do ³añcuchów
prefiksy (g³ówny i prefiks typu) oraz treœæ. Przekazywany tak¿e typ mo¿e
wykorzystaæ do realizacji w³asnego mapowania, np. na kolor. Jej obowi¹zkiem
jest dostosowanie treœci wszystkich otrzymanych ³añchów do kodowania znaków i
koñców wiersza obowi¹zuj¹cego w miejscu docelowym. Wejœciowe kodowanie znaków
to Windows-1250, a koñców wiersza - nieokreœlone.

Klasa ta nie musi byæ bezpieczna w¹tkowo - o bezpieczeñstwo w¹tkowe dba sam
logger. Metody tej klasy mog¹ byæ wywo³ywane z ró¿nych w¹tków, ale nigdy nie
bêd¹ wywo³ywane równoczeœnie.

